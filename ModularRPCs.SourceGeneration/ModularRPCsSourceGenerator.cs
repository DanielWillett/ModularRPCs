using DanielWillett.ModularRpcs.Annotations;
using DanielWillett.ModularRpcs.SourceGeneration.Generators;
using DanielWillett.ModularRpcs.SourceGeneration.Util;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;

namespace DanielWillett.ModularRpcs.SourceGeneration;

[Generator(LanguageNames.CSharp)]
public class ModularRPCsSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static postInitializationContext =>
        {
            // in a later update we can do postInitializationContext.AddEmbeddedAttributeDefinition()
            postInitializationContext.AddSource("Microsoft.CodeAnalysis.EmbeddedAttribute",
                SourceText.From(
                    """
                    // <auto-generated/>
                    namespace Microsoft.CodeAnalysis
                    {
                        internal sealed partial class EmbeddedAttribute : global::System.Attribute
                        {
                        }
                    }
                    """)
            );

            postInitializationContext.AddSource("DanielWillett.ModularRpcs.Annotations.GenerateRpcSource",
                SourceText.From(
                    """
                    // <auto-generated/>
                    namespace DanielWillett.ModularRpcs.Annotations
                    {
                        /// <summary>
                        /// Tells the source generator to create a proxy class at compile time instead of at runtime. This type must be partial, non-static, and non-sealed.
                        /// </summary>
                        /// <remarks>A <see cref="T:DanielWillett.ModularRpcs.Annotations.RpcExplicitProxyType"/> will be added to this type.</remarks>
                        [global::System.AttributeUsageAttribute(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct)]
                        [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
                        internal sealed partial class GenerateRpcSourceAttribute : global::System.Attribute
                        {
                        }
                    }
                    """)
            );
        });

        IncrementalValuesProvider<RpcClassDeclaration> classes = context.SyntaxProvider.ForAttributeWithMetadataName(
            "DanielWillett.ModularRpcs.Annotations.GenerateRpcSourceAttribute",
            static (n, _) => n is ClassDeclarationSyntax or StructDeclarationSyntax,
            static (n, _) =>
            {
                ITypeSymbol symbol = (ITypeSymbol)n.TargetSymbol;

                ClassError error = ClassError.None;
                if (symbol.IsStatic)
                    error = ClassError.Static;
                else if (symbol.ContainingType != null)
                    error = ClassError.Nested;
                else if (!symbol.CanBeReferencedByName)
                    error = ClassError.Invalid;

                return new RpcClassDeclaration(symbol.ContainingNamespace.ToDisplayString(), symbol.Name, error, symbol.IsValueType);
            });

        IncrementalValuesProvider<RpcMethodDeclaration> methods = context.SyntaxProvider.ForAttributeWithMetadataName(
            "DanielWillett.ModularRpcs.Annotations.GenerateRpcSourceAttribute",
            static (n, _) => n is ClassDeclarationSyntax or StructDeclarationSyntax,
            static (n, _) =>
            {
                ITypeSymbol symbol = (ITypeSymbol)n.TargetSymbol;
                return symbol;
            })
            .SelectMany(EnumerateMethods);

        context.RegisterSourceOutput(classes, static (n, c) =>
        {
            new ClassSnippetGenerator(n, c).GenerateClassSnippet();
        });

        context.RegisterSourceOutput(methods, static (n, m) =>
        {
            if (m.IsReceive)
                new ReceiveMethodSnippetGenerator(n, m).GenerateClassSnippet();
            else
                new SendMethodSnippetGenerator(n, m).GenerateClassSnippet();
        });
    }

    private static IEnumerable<RpcMethodDeclaration> EnumerateMethods(ITypeSymbol symbol, CancellationToken token)
    {
        foreach (IMethodSymbol method in symbol.GetMembers().OfType<IMethodSymbol>())
        {
            RpcTargetAttribute? attribute = method.GetAttributes().Select(GetRpcTypeAttribute).FirstOrDefault(x => x != null);
            if (attribute == null)
                continue;

            token.ThrowIfCancellationRequested();
            yield return new RpcMethodDeclaration
            {
                Type = new RpcClassDeclaration(symbol.ContainingNamespace.ToDisplayString(), symbol.Name, ClassError.None, symbol.IsValueType),
                Target = attribute,
                Name = method.Name,
                Parameters = new EquatableList<RpcParameterDeclaration>(method.Parameters.Select(GetRpcParameter).Where(x => x != null))
            };
        }
    }

    private static RpcParameterDeclaration GetRpcParameter(IParameterSymbol arg)
    {
        return null;
    }

    private static RpcTargetAttribute? GetRpcTypeAttribute(AttributeData attributeData)
    {
        bool isSend = attributeData.AttributeClass.IsEqualTo("global::DanielWillett.ModularRpcs.Annotations.RpcSendAttribute");
        bool isReceive = attributeData.AttributeClass.IsEqualTo("global::DanielWillett.ModularRpcs.Annotations.RpcReceiveAttribute");
        if (!isSend && !isReceive)
            return null;

        RpcTargetAttribute attribute;
        if (attributeData.AttributeConstructor == null || attributeData.AttributeConstructor.Parameters.Length == 0)
        {
            attribute = isSend ? new RpcSendAttribute() : new RpcReceiveAttribute();
        }
        else if (attributeData.AttributeConstructor.Parameters.Length == 1)
        {
            TypedConstant methodName = attributeData.ConstructorArguments[0];
            if (methodName.Kind != TypedConstantKind.Primitive && methodName.Type.IsEqualTo("global::System.String"))
            {
                return null;
            }

            string? methodNameStr = (string?)methodName.Value;

            if (methodNameStr == null)
            {
                return null;
            }

            attribute = isSend ? new RpcSendAttribute(methodNameStr) : new RpcReceiveAttribute(methodNameStr);
        }
        else if (attributeData.AttributeConstructor.Parameters.Length == 2)
        {
            TypedConstant declaringType = attributeData.ConstructorArguments[0];
            TypedConstant methodName = attributeData.ConstructorArguments[1];
            if (methodName.Kind != TypedConstantKind.Primitive && methodName.Type.IsEqualTo("global::System.String"))
            {
                return null;
            }
            if (declaringType.Kind != TypedConstantKind.Primitive && declaringType.Type.IsEqualTo("global::System.String"))
            {
                if (declaringType.Kind != TypedConstantKind.Type)
                    return null;
            }

            string? typeName = declaringType.Kind == TypedConstantKind.Type
                ? ((ITypeSymbol?)declaringType.Value)?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                : (string)declaringType.Value!;

            string? methodNameStr = (string?)methodName.Value;

            if (typeName == null || methodNameStr == null)
            {
                return null;
            }

            attribute = isSend ? new RpcSendAttribute(typeName, methodNameStr) : new RpcReceiveAttribute(typeName, methodNameStr);
        }
        else
        {
            return null;
        }

        KeyValuePair<string, TypedConstant> isRaw = attributeData.NamedArguments.FirstOrDefault(
            x => x.Key.Equals(nameof(RpcTargetAttribute.Raw), StringComparison.Ordinal)
        );
        if (isRaw.Key is not null && isRaw.Value is { Kind: TypedConstantKind.Primitive, Value: bool isRawVal })
        {
            attribute.Raw = isRawVal;
        }

        KeyValuePair<string, TypedConstant> paramsAreBindedOnly = attributeData.NamedArguments.FirstOrDefault(
            x => x.Key.Equals(nameof(RpcTargetAttribute.ParametersAreBindedParametersOnly), StringComparison.Ordinal)
        );
        if (paramsAreBindedOnly.Key is not null && paramsAreBindedOnly.Value is { Kind: TypedConstantKind.Primitive, Value: bool paramsAreBindedOnlyVal })
        {
            attribute.ParametersAreBindedParametersOnly = paramsAreBindedOnlyVal;
        }

        KeyValuePair<string, TypedConstant> parameterTypes = attributeData.NamedArguments.FirstOrDefault(
            x => x.Key.Equals(nameof(RpcTargetAttribute.ParameterTypes), StringComparison.Ordinal)
        );
        if (parameterTypes.Key is not null && parameterTypes.Value is { Kind: TypedConstantKind.Array, IsNull: false })
        {
            ImmutableArray<TypedConstant> arr = parameterTypes.Value.Values;
            attribute.ParameterTypeNames = arr
                .Where(x => x is { Kind: TypedConstantKind.Type, Value: ITypeSymbol })
                .Select(x => (x.Value as ITypeSymbol)!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                .ToArray();
        }

        KeyValuePair<string, TypedConstant> parameterNames = attributeData.NamedArguments.FirstOrDefault(
            x => x.Key.Equals(nameof(RpcTargetAttribute.ParameterTypeNames), StringComparison.Ordinal)
        );
        if (parameterNames.Key is not null && parameterNames.Value is { Kind: TypedConstantKind.Array, IsNull: false })
        {
            ImmutableArray<TypedConstant> arr = parameterNames.Value.Values;
            attribute.ParameterTypeNames = arr
                .Where(x => x is { Kind: TypedConstantKind.Primitive, Value: string })
                .Select(x => (x.Value as string)!)
                .ToArray();
        }

        return attribute;
    }
}

internal enum RpcAttributeType
{
    RpcSend,
    RpcReceive,
    RpcTimeout
}

internal enum ClassError
{
    None,
    Static,
    Nested,
    Invalid
}

internal record RpcClassDeclaration(string Namespace, string Name, ClassError Error, bool IsStruct);