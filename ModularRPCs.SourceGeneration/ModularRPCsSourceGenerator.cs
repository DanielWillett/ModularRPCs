using DanielWillett.ModularRpcs.Annotations;
using DanielWillett.ModularRpcs.Protocol;
using DanielWillett.ModularRpcs.SourceGeneration.Generators;
using DanielWillett.ModularRpcs.SourceGeneration.Util;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace DanielWillett.ModularRpcs.SourceGeneration;

[Generator(LanguageNames.CSharp)]
public class ModularRPCsSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static postInitializationContext =>
        {
            postInitializationContext.AddEmbeddedAttributeDefinition();
            postInitializationContext.AddSource("DanielWillett.ModularRpcs.Annotations.GenerateRpcSourceAttribute",
                SourceText.From(
                    """
                    // <auto-generated/>
                    namespace DanielWillett.ModularRpcs.Annotations
                    {
                        /// <summary>
                        /// Tells the source generator to create a proxy class at compile time instead of at runtime. This type must be partial, non-static, and non-sealed.
                        /// </summary>
                        /// <remarks>A <see cref="T:DanielWillett.ModularRpcs.Annotations.RpcExplicitProxyType"/> will be added to this type.</remarks>
                        [global::System.AttributeUsageAttribute(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct)]
                        [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
                        internal sealed partial class GenerateRpcSourceAttribute : global::System.Attribute
                        {
                        }
                    }
                    """, Encoding.UTF8)
            );

            postInitializationContext.AddSource("DanielWillett.ModularRpcs.Annotations.IgnoreGenerateRpcSourceAttribute",
                SourceText.From(
                    """
                    // <auto-generated/>
                    namespace DanielWillett.ModularRpcs.Annotations
                    {
                        /// <summary>
                        /// Tells the source generator to ignore a <see cref="T:DanielWillett.ModularRpcs.Annotations.GenerateRpcSourceAttribute"/> on this type for some reason.
                        /// </summary>
                        [global::System.AttributeUsageAttribute(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct)]
                        [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
                        internal sealed partial class IgnoreGenerateRpcSourceAttribute : global::System.Attribute
                        {
                        }
                    }
                    """, Encoding.UTF8)
            );
        });

        IncrementalValuesProvider<(ITypeSymbol Node, RpcClassDeclaration Declaration)> symbolsAndClassDefs =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                "DanielWillett.ModularRpcs.Annotations.GenerateRpcSourceAttribute",
                static (n, _) => n is ClassDeclarationSyntax or StructDeclarationSyntax,
                static (n, _) =>
                {
                    ITypeSymbol symbol = (ITypeSymbol)n.TargetSymbol;

                    ClassError error = ClassError.None;
                    if (symbol.IsStatic)
                        error = ClassError.Static;
                    else if (symbol.ContainingType != null)
                        error = ClassError.Nested;
                    else if (!symbol.CanBeReferencedByName)
                        error = ClassError.Invalid;
                    else if (symbol.IsValueType)
                        error = ClassError.Struct;

                    INamedTypeSymbol? rpcObjectInterface = symbol.GetImplementation(
                        x => x.IsGenericType && x.ConstructedFrom.IsEqualTo("global::DanielWillett.ModularRpcs.Protocol.IRpcObject<T>")
                    );
                    INamedTypeSymbol? singleConnectionInterface = symbol.GetImplementation(
                        x => !x.IsGenericType && x.ConstructedFrom.IsEqualTo("global::DanielWillett.ModularRpcs.Protocol.IRpcSingleConnectionObject")
                    );
                    INamedTypeSymbol? multiConnectionInterface = symbol.GetImplementation(
                        x => !x.IsGenericType && x.ConstructedFrom.IsEqualTo("global::DanielWillett.ModularRpcs.Protocol.IRpcMultipleConnectionsObject")
                    );

                    ITypeSymbol? idType = rpcObjectInterface?.TypeArguments[0];

                    bool explicitId = rpcObjectInterface.IsExplicitlyImplemented<IPropertySymbol>(symbol, nameof(IRpcObject<object>.Identifier));
                    bool explicitSingle = singleConnectionInterface.IsExplicitlyImplemented<IPropertySymbol>(symbol, nameof(IRpcSingleConnectionObject.Connection));
                    bool explicitMulti = multiConnectionInterface.IsExplicitlyImplemented<IPropertySymbol>(symbol, nameof(IRpcMultipleConnectionsObject.Connections));

                    bool isUnityType = false;

                    for (ITypeSymbol? baseType = symbol.BaseType; baseType != null; baseType = baseType.BaseType)
                    {
                        if (baseType.IsEqualTo("global::UnityEngine.MonoBehaviour, UnityEngine.CoreModule"))
                        {
                            isUnityType = true;
                            break;
                        }
                    }

                    return (
                        Node: symbol,
                        Declaration: new RpcClassDeclaration
                        {
                            Error = error,
                            Definition = symbol.ToDisplayString(CustomFormats.TypeDeclarationFormat),
                            IsValueType = symbol.IsValueType,
                            Type = new TypeSymbolInfo(n.SemanticModel.Compilation, symbol),
                            IdType = idType == null ? null : new TypeSymbolInfo(n.SemanticModel.Compilation, idType, createInfo: true),
                            IdTypeCode = TypeHelper.GetTypeCode(idType),
                            IdIsExplicit = explicitId,
                            IsUnityType = isUnityType,
                            IsSingleConnectionObject = singleConnectionInterface != null, 
                            IsSingleConnectionExplicit = explicitSingle,
                            IsMultipleConnectionObject = multiConnectionInterface != null,
                            IsMultipleConnectionExplicit = explicitMulti
                        }
                    );
                })
                .WithTrackingName("ModularRPCs_AllGeneratedRpcClasses")
                .Where(info =>
                {
                    return info.Node.GetAttributes().All(x => !x.AttributeClass.IsEqualTo(
                        "global::DanielWillett.ModularRpcs.Annotations.IgnoreGenerateRpcSourceAttribute"
                    ));
                })
                .WithTrackingName("ModularRPCs_FilteredGeneratedRpcClasses");

        IncrementalValuesProvider<(RpcClassDeclaration Declaration, EquatableList<RpcMethodDeclaration> Methods, Compilation Compilation)> compositedClasses =
            symbolsAndClassDefs
                .Where(x => x.Declaration.Error == ClassError.None)
                .Combine(context.CompilationProvider)
                .Select((x, token) => (x.Left.Declaration, new EquatableList<RpcMethodDeclaration>(EnumerateMethods(x.Right, x.Left, token)), x.Right))
                .WithTrackingName("ModularRPCs_FilteredGeneratedRpcClassesAndMethods");

        context.RegisterSourceOutput(compositedClasses, static (n, c) =>
        {
            new ClassSnippetGenerator(n, (CSharpCompilation)c.Compilation, c.Declaration, c.Methods).GenerateClassSnippet();
        });
    }

    private static IEnumerable<RpcMethodDeclaration> EnumerateMethods(Compilation compilation, (ITypeSymbol symbol, RpcClassDeclaration Declaration) info, CancellationToken token)
    {
        (ITypeSymbol symbol, RpcClassDeclaration decl) = info;
        foreach (IMethodSymbol method in symbol.GetMembers().OfType<IMethodSymbol>())
        {
            RpcTargetAttribute? attribute = method.GetAttributes().Select(GetRpcTypeAttribute).FirstOrDefault(x => x != null);
            if (attribute == null)
                continue;
            
            token.ThrowIfCancellationRequested();

            bool isFireAndForget = false;
            if (method.ReturnType.IsEqualTo("global::DanielWillett.ModularRpcs.Async.RpcTask"))
            {
                isFireAndForget = method.GetAttributes().Any(
                    x => x.AttributeClass.IsEqualTo("global::DanielWillett.ModularRpcs.Annotations.RpcFireAndForgetAttribute")
                );
            }
            else if (method.ReturnType.IsEqualTo("global::System.Void"))
            {
                isFireAndForget = true;
            }

            yield return new RpcMethodDeclaration
            {
                Type = decl,
                Target = attribute,
                Visibility = method.DeclaredAccessibility,
                Name = method.Name,
                Definition = CustomFormats.InsertPartial(method.ToDisplayString(CustomFormats.MethodDeclarationFormat)),
                XmlDocs = CustomFormats.GetXmlDocReference(method),
                Parameters = new EquatableList<RpcParameterDeclaration>(method.Parameters.Select((arg, index) =>
                {
                    TypeSymbolInfo symbolInfo = new TypeSymbolInfo(compilation, arg.Type, createInfo: true);
                    return new RpcParameterDeclaration
                    {
                        Index = index,
                        Name = arg.Name,
                        Type = symbolInfo,
                        InjectType = ParameterHelper.GetAutoInjectType(arg.Type as INamedTypeSymbol),
                        IsManualInjected = arg.GetAttributes().Any(
                            x => x.AttributeClass.IsEqualTo("global::DanielWillett.ModularRpcs.Annotations.RpcInjectAttribute")
                        ),
                        PrimitiveLikeType = TypeHelper.GetPrimitiveLikeType(arg.Type as INamedTypeSymbol),
                        Definition = arg.ToDisplayString(CustomFormats.MethodDeclarationFormat),
                        RefKind = arg.RefKind
                    };
                }).Where(x => x != null)),
                ReturnType = new TypeSymbolInfo(compilation, method.ReturnType),
                IsFireAndForget = isFireAndForget
            };
        }
    }

    private static RpcTargetAttribute? GetRpcTypeAttribute(AttributeData attributeData)
    {
        bool isSend = attributeData.AttributeClass.IsEqualTo("global::DanielWillett.ModularRpcs.Annotations.RpcSendAttribute");
        bool isReceive = attributeData.AttributeClass.IsEqualTo("global::DanielWillett.ModularRpcs.Annotations.RpcReceiveAttribute");
        if (!isSend && !isReceive)
            return null;

        RpcTargetAttribute attribute;
        if (attributeData.AttributeConstructor == null || attributeData.AttributeConstructor.Parameters.Length == 0)
        {
            attribute = isSend ? new RpcSendAttribute() : new RpcReceiveAttribute();
        }
        else if (attributeData.AttributeConstructor.Parameters.Length == 1)
        {
            TypedConstant methodName = attributeData.ConstructorArguments[0];
            if (methodName.Kind != TypedConstantKind.Primitive && methodName.Type.IsEqualTo("global::System.String"))
            {
                return null;
            }

            string? methodNameStr = (string?)methodName.Value;

            if (methodNameStr == null)
            {
                return null;
            }

            attribute = isSend ? new RpcSendAttribute(methodNameStr) : new RpcReceiveAttribute(methodNameStr);
        }
        else if (attributeData.AttributeConstructor.Parameters.Length == 2)
        {
            TypedConstant declaringType = attributeData.ConstructorArguments[0];
            TypedConstant methodName = attributeData.ConstructorArguments[1];
            if (methodName.Kind != TypedConstantKind.Primitive && methodName.Type.IsEqualTo("global::System.String"))
            {
                return null;
            }
            if (declaringType.Kind != TypedConstantKind.Primitive && declaringType.Type.IsEqualTo("global::System.String"))
            {
                if (declaringType.Kind != TypedConstantKind.Type)
                    return null;
            }

            string? typeName = declaringType.Kind == TypedConstantKind.Type
                ? ((ITypeSymbol?)declaringType.Value)?.ToDisplayString(CustomFormats.FullTypeNameWithGlobalFormat)
                : (string)declaringType.Value!;

            string? methodNameStr = (string?)methodName.Value;

            if (typeName == null || methodNameStr == null)
            {
                return null;
            }

            attribute = isSend ? new RpcSendAttribute(typeName, methodNameStr) : new RpcReceiveAttribute(typeName, methodNameStr);
        }
        else
        {
            return null;
        }

        KeyValuePair<string, TypedConstant> isRaw = attributeData.NamedArguments.FirstOrDefault(
            x => x.Key.Equals(nameof(RpcTargetAttribute.Raw), StringComparison.Ordinal)
        );
        if (isRaw.Key is not null && isRaw.Value is { Kind: TypedConstantKind.Primitive, Value: bool isRawVal })
        {
            attribute.Raw = isRawVal;
        }

        KeyValuePair<string, TypedConstant> paramsAreBindedOnly = attributeData.NamedArguments.FirstOrDefault(
            x => x.Key.Equals(nameof(RpcTargetAttribute.ParametersAreBindedParametersOnly), StringComparison.Ordinal)
        );
        if (paramsAreBindedOnly.Key is not null && paramsAreBindedOnly.Value is { Kind: TypedConstantKind.Primitive, Value: bool paramsAreBindedOnlyVal })
        {
            attribute.ParametersAreBindedParametersOnly = paramsAreBindedOnlyVal;
        }

        KeyValuePair<string, TypedConstant> parameterTypes = attributeData.NamedArguments.FirstOrDefault(
            x => x.Key.Equals(nameof(RpcTargetAttribute.ParameterTypes), StringComparison.Ordinal)
        );
        if (parameterTypes.Key is not null && parameterTypes.Value is { Kind: TypedConstantKind.Array, IsNull: false })
        {
            ImmutableArray<TypedConstant> arr = parameterTypes.Value.Values;
            attribute.ParameterTypeNames = arr
                .Where(x => x is { Kind: TypedConstantKind.Type, Value: ITypeSymbol })
                .Select(x => ((ITypeSymbol)x.Value!).ToDisplayString(CustomFormats.FullTypeNameWithGlobalFormat))
                .ToArray();
        }

        KeyValuePair<string, TypedConstant> parameterNames = attributeData.NamedArguments.FirstOrDefault(
            x => x.Key.Equals(nameof(RpcTargetAttribute.ParameterTypeNames), StringComparison.Ordinal)
        );
        if (parameterNames.Key is not null && parameterNames.Value is { Kind: TypedConstantKind.Array, IsNull: false })
        {
            ImmutableArray<TypedConstant> arr = parameterNames.Value.Values;
            attribute.ParameterTypeNames = arr
                .Where(x => x is { Kind: TypedConstantKind.Primitive, Value: string })
                .Select(x => (string)x.Value!)
                .ToArray();
        }

        return attribute;
    }
}

internal enum RpcAttributeType
{
    RpcSend,
    RpcReceive,
    RpcTimeout
}

internal enum ClassError
{
    None,
    Static,
    Nested,
    Invalid,
    Struct
}

internal record RpcClassDeclaration
{
    public required TypeSymbolInfo Type { get; init; }
    public required string Definition { get; init; }
    public required ClassError Error { get; init; }
    public required bool IsValueType { get; init; }
    public required bool IsSingleConnectionObject { get; init; }
    public required bool IsSingleConnectionExplicit { get; set; }
    public required bool IsMultipleConnectionObject { get; init; }
    public required bool IsMultipleConnectionExplicit { get; set; }

    public bool IsUnityType { get; init; }


    /// <summary>
    /// <see langword="null"/> if not an <see cref="IRpcObject{T}"/>.
    /// </summary>
    public TypeSymbolInfo? IdType { get; init; }
    public bool IdIsExplicit { get; init; }
    public TypeCode IdTypeCode { get; init; }
}