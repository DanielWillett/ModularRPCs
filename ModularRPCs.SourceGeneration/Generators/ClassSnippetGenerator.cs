using DanielWillett.ModularRpcs.SourceGeneration.Util;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;

namespace DanielWillett.ModularRpcs.SourceGeneration.Generators;

internal readonly struct ClassSnippetGenerator
{
    public readonly SourceProductionContext Context;
    public readonly RpcClassDeclaration Class;
    public readonly EquatableList<RpcMethodDeclaration> MethodDeclarations;
    public readonly CSharpCompilation Compilation;

    internal ClassSnippetGenerator(SourceProductionContext context, CSharpCompilation compilation, RpcClassDeclaration @class, EquatableList<RpcMethodDeclaration> methodDeclarations)
    {
        Compilation = compilation;
        Context = context;
        Class = @class;
        MethodDeclarations = methodDeclarations;
    }

    public void GenerateClassSnippet()
    {
        Context.CancellationToken.ThrowIfCancellationRequested();

        const string receiveInvokeNamePrefix = "ModularRpcsGeneratedInvoke";
        const string callMethodInfoFieldPrefix = "_modularRpcsGeneratedCallMethodInfo";

        SourceStringBuilder bldr = new SourceStringBuilder(2048, CultureInfo.InvariantCulture);

        List<SendMethodInfo> sendMethods = MethodDeclarations
            .Where(x => x.IsSend)
            .OrderBy(x => x.Name)
            .Select(x => new SendMethodInfo(x, -1, null!))
            .ToList();

        List<ReceiveMethodInfo> recvMethods = MethodDeclarations
            .Where(x => x.IsReceive)
            .OrderBy(x => x.Name)
            .Select(x => new ReceiveMethodInfo(x, -1))
            .ToList();

        int overload = 0;
        string? last = null;
        for (int i = 0; i < recvMethods.Count; i++)
        {
            ReceiveMethodInfo info = recvMethods[i];
            if (!string.Equals(info.Method.Name, last, StringComparison.Ordinal))
                overload = 0;
            else
                ++overload;

            info.Overload = overload;
            info.ReceiveMethodNameBytes = $"{receiveInvokeNamePrefix}{info.Method.Name}Ovl{info.Overload}Bytes";
            info.ReceiveMethodNameStream = $"{receiveInvokeNamePrefix}{info.Method.Name}Ovl{info.Overload}Stream";
            recvMethods[i] = info;
        }

        overload = 0;
        last = null;
        for (int i = 0; i < sendMethods.Count; i++)
        {
            SendMethodInfo info = sendMethods[i];
            if (!string.Equals(info.Method.Name, last, StringComparison.Ordinal))
                overload = 0;
            else
                ++overload;

            info.Overload = overload;
            info.MethodInfoFieldName = $"{callMethodInfoFieldPrefix}{info.Method.Name}Ovl{overload.ToString(CultureInfo.InvariantCulture)}";
            sendMethods[i] = info;
        }

        // namespace {
        bldr.String("// <auto-generated/>")
            .Preprocessor("#nullable disable")
            .Build($"{Class.Type.NamespaceDeclaration}")
            .String("{").In();

        // class attributes
        bldr.String("[global::DanielWillett.ModularRpcs.Annotations.RpcGeneratedProxyTypeAttribute(");
        if (sendMethods.Count > 0 || recvMethods.Count > 0)
        {
            bldr.Preprocessor("#if !NET7_0_OR_GREATER");
            bldr.In().Build($"TypeSetupMethodName = nameof(@{Class.Type.Name}.__ModularRpcsGeneratedSetupStaticGeneratedProxy)").Out();
            bldr.Preprocessor("#endif");
        }
        bldr.String(")]");

        // class {
        bldr.Build($"partial {Class.Definition} : global::DanielWillett.ModularRpcs.Reflection.IRpcGeneratedProxyType")
            .String("{").In()
                .Empty()
                .String("#region ModularRPCs class-level infrastructure")
                .Empty()
                .String("/// <summary>")
                .String("/// Stores generic information that is needed by all proxy types to send and receive RPCs.")
                .String("/// </summary>")
                .String("[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]")
                .String("[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]")
                .String("private global::DanielWillett.ModularRpcs.Reflection.ProxyContext __modularRpcsGeneratedProxyContext;")
                .Empty()
                .String("/// <summary>")
                .String("/// Invoked after this type is created by <see cref=\"M:DanielWillett.ModularRpcs.Reflection.ProxyGenerator.CreateProxy\">.")
                .String("/// </summary>")
                .String("[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]")
                .String("[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]")
                .String("void global::DanielWillett.ModularRpcs.Reflection.IRpcGeneratedProxyType.SetupGeneratedProxyInfo(").In()
                    .String("in global::DanielWillett.ModularRpcs.Reflection.GeneratedProxyTypeInfo info)").Out()
                .String("{").In()
                    .Build($"info.Router.GetDefaultProxyContext(typeof(@{Class.Type.Name}), out this.__modularRpcsGeneratedProxyContext);").Out()
                .String("}")
                .Empty();

        // static init method

        if (sendMethods.Count == 0 && recvMethods.Count == 0)
        {
            bldr.Preprocessor("#if NET7_0_OR_GREATER");
        }
        
        bldr.String("[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]")
            .String("[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]")
            .Preprocessor("#if NET7_0_OR_GREATER")
            .String("public")
            .Preprocessor("#else")
            .String("private")
            .Preprocessor("#endif")
            .String("static unsafe void __ModularRpcsGeneratedSetupStaticGeneratedProxy(").In()
                .String("global::DanielWillett.ModularRpcs.Reflection.GeneratedProxyTypeBuilder state)").Out()
            .String("{").In();

        foreach (SendMethodInfo method in sendMethods)
        {
            if (Class.IsValueType)
            {
                bldr.Build($"state.AddCallGetter(static () => @{Class.Type.Name}.{method.MethodInfoFieldName});");
            }
            else
            {
                bldr.Build($"state.AddCallGetter(static () => ref @{Class.Type.Name}.{method.MethodInfoFieldName});");
            }
            bldr.Build($"state.AddMethodSignatureHash(@{Class.Type.Name}.{method.MethodInfoFieldName}.MethodHandle, {method.Method.SignatureHash});");
        }

        if (recvMethods.Count > 0)
        {
            if (sendMethods.Count > 0)
                bldr.Empty();

            bldr.String("global::System.RuntimeMethodHandle workingHandle;");

            foreach (ReceiveMethodInfo method in recvMethods)
            {
                bldr.Empty()
                    .Build($"// Register {method.Method.Name}")
                    .Build($"workingHandle = global::DanielWillett.ModularRpcs.Reflection.SourceGenerationServices.GetMethodByExpression<global::System.Action<{Class.Type.GloballyQualifiedName}>>(").In()
                    .Build($"@{Class.Type.Name} => @{Class.Type.Name}.@{method.Method.Name}(").In();

                bool needsComma = false;
                foreach (RpcParameterDeclaration parameter in method.Method.Parameters)
                {
                    string comma = needsComma ? ", " : string.Empty;
                    bldr.Build($"{comma}default({parameter.Type.GloballyQualifiedName})");
                    needsComma = true;
                }

                bldr.Out()
                    .String(")").Out()
                    .String(").MethodHandle;");

                bldr.String("state.AddReceiveMethod(").In()
                        .String("workingHandle,")
                        .String(method.Method.Target.Raw
                            ? "global::DanielWillett.ModularRpcs.Reflection.GeneratedProxyTypeBuilder.ReceiveMethodInvokerType.BytesRaw,"
                            : "global::DanielWillett.ModularRpcs.Reflection.GeneratedProxyTypeBuilder.ReceiveMethodInvokerType.Bytes,")
                        .String(method.Method.Target.Raw
                            ? "new global::DanielWillett.ModularRpcs.Reflection.ProxyGenerator.RpcInvokeHandlerRawBytes("
                            : "new global::DanielWillett.ModularRpcs.Reflection.ProxyGenerator.RpcInvokeHandlerBytes(").In()
                            .Build($"@{Class.Type.Name}.{method.ReceiveMethodNameBytes}")
                            .Out()
                        .String(")")
                        .Out()
                    .String(");");

                bldr.String("state.AddReceiveMethod(").In()
                        .String("workingHandle,")
                        .String(method.Method.Target.Raw
                            ? "global::DanielWillett.ModularRpcs.Reflection.GeneratedProxyTypeBuilder.ReceiveMethodInvokerType.StreamRaw,"
                            : "global::DanielWillett.ModularRpcs.Reflection.GeneratedProxyTypeBuilder.ReceiveMethodInvokerType.Stream,")
                        .String("new global::DanielWillett.ModularRpcs.Reflection.ProxyGenerator.RpcInvokeHandlerStream(").In()
                            .Build($"@{Class.Type.Name}.{method.ReceiveMethodNameStream}")
                            .Out()
                        .String(")")
                        .Out()
                    .String(");");

                bldr.Build($"state.AddMethodSignatureHash(workingHandle, {method.Method.SignatureHash});");
            }
        }

        bldr.Out()
            .String("}");

        if (sendMethods.Count == 0 && recvMethods.Count == 0)
        {
            bldr.Preprocessor("#endif");
        }

        bldr.String("#endregion")
            .Empty();

        // send methods
        bldr.Empty()
            .Empty()
            .String("#region Generated send stubs");
        foreach (SendMethodInfo method in sendMethods)
        {
            bldr.Empty()
                .String("[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]")
                .String("[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]")
                .Build($"private static global::DanielWillett.ModularRpcs.Reflection.RpcCallMethodInfo {method.MethodInfoFieldName}").In()
                    .String("= new global::DanielWillett.ModularRpcs.Reflection.RpcCallMethodInfo()")
                    .String("{").In()
                        .Build($"MethodHandle = global::DanielWillett.ModularRpcs.Reflection.SourceGenerationServices.GetMethodByExpression<global::System.Action<{Class.Type.GloballyQualifiedName}>>(").In()
                            .Build($"@{Class.Type.Name} => @{Class.Type.Name}.@{method.Method.Name}({(method.Method.Parameters.Count == 0 ? ")" : string.Empty)}");

            if (method.Method.Parameters.Count > 0)
            {
                bool needsComma = false;
                foreach (RpcParameterDeclaration parameter in method.Method.Parameters)
                {
                    string comma = needsComma ? ", " : string.Empty;
                    bldr.Build($"{comma}default({parameter.Type.GloballyQualifiedName})");
                    needsComma = true;
                }

                bldr.Out()
                    .String(")");
            }

            bldr.Out()
                .String(").MethodHandle,")
                .Build($"IsFireAndForget = {(method.Method.IsFireAndForget ? "true" : "false")},")
                .Build($"SignatureHash = {method.Method.SignatureHash},")
                .Build($"HasIdentifier = {(Class.IdType == null ? "false" : "true")},");
            if (method.Method.Timeout.Ticks == 0)
            {
                bldr.Build($"Timeout = global::System.TimeSpan.Zero,");
            }
            else
            {
                bldr.Build($"Timeout = new global::System.TimeSpan({method.Method.Timeout.Ticks}),");
            }
            bldr.String("Endpoint = new global::DanielWillett.ModularRpcs.Reflection.RpcEndpointTarget()")
                .String("{").In()
                    .Build($"MethodName = \"{TypeHelper.Escape(string.IsNullOrEmpty(method.Method.Target.MethodName) ? method.Method.Name : method.Method.Target.MethodName!)}\",")
                    .Build($"DeclaringTypeName = \"{TypeHelper.Escape(string.IsNullOrEmpty(method.Method.Target.TypeName) ? Class.Type.AssemblyQualifiedName : method.Method.Target.TypeName!)}\",")
                    .Build($"SignatureHash = {method.Method.SignatureHash},")
                    .String("IgnoreSignatureHash = false,")
                    .Build($"ParameterTypesAreBindOnly = {(method.Method.Target.ParametersAreBindedParametersOnly ? "true" : "false")},");
            if (method.Method.Target.ParameterTypeNames == null)
            {
                bldr.String("ParameterTypes = null,");
            }
            else if (method.Method.Target.ParameterTypeNames.Length == 0)
            {
                bldr.String("ParameterTypes = global::System.Array.Empty<string>(),");
            }
            else
            {
                string types = string.Join("\", \"", method.Method.Target.ParameterTypeNames.Select(TypeHelper.Escape));
                bldr.Build($"ParameterTypes = new string[] {{ \"{types}\" }},");
            }

            bldr    .Build($"IsBroadcast = {(method.Method.IsBroadcast ? "true" : "false")},")
                    .String("OwnerMethodInfo = null").Out()
                .String("}")
                .Out()
                .String("};");

            bldr.Empty()
                .String("/// <summary>")
                .Build($"/// Generated receive invoker for <see cref=\"{method.Method.XmlDocs}\"> (Overload {method.Overload + 1}).")
                .String("/// </summary>")
                .String("/// <remarks>This method is responsible for triggering the initial RPC invocation.</remarks>")
                .Empty();

            bldr.Build($"{method.Method.Definition}")
                .String("{").In();

            new SendMethodSnippetGenerator(Context, Compilation, method)
                .GenerateMethodBodySnippet(bldr);

            bldr.Out()
                .String("}");
        }

        bldr.Empty()
            .String("#endregion");

        // receive methods
        bldr.Empty()
            .Empty()
            .String("#region Generated receive invokers");
        foreach (ReceiveMethodInfo method in recvMethods)
        {
            bldr.Empty()
                .String("/// <summary>")
                .Build($"/// Generated raw binary receive invoker for <see cref=\"{method.Method.XmlDocs}\"> (Overload {method.Overload + 1}).")
                .String("/// </summary>")
                .String("/// <remarks>This method is responsible for parsing the data received by another party and invoking the receive method.</remarks>")
                .Empty();

            bldr.String("[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]")
                .String("[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]")
                .Build($"private static unsafe void {method.ReceiveMethodNameBytes}(").In()
                    .String("object serviceProvider,")
                    .String("object targetObject,")
                    .String("global::DanielWillett.ModularRpcs.Protocol.RpcOverhead overhead,")
                    .String("global::DanielWillett.ModularRpcs.Routing.IRpcRouter router,")
                    .String("global::DanielWillett.ModularRpcs.Serialization.IRpcSerializer serializer,")
                    .String("byte* bytes,")
                    .String("uint maxSize,")
                    .String("global::System.Threading.CancellationToken token)").Out()
                .String("{").In();

            new ReceiveMethodSnippetGenerator(Context, Compilation, method)
                .GenerateMethodBodySnippet(bldr, stream: false);

            bldr.Out()
                .String("}");

            bldr.Empty()
                .String("/// <summary>")
                .Build($"/// Generated stream receive invoker for <see cref=\"{method.Method.XmlDocs}\"> (Overload {method.Overload + 1}).")
                .String("/// </summary>")
                .String("/// <remarks>This method is responsible for parsing the data received by another party and invoking the receive method.</remarks>")
                .Empty();

            bldr.String("[global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]")
                .String("[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]")
                .Build($"private static unsafe void {method.ReceiveMethodNameStream}(").In()
                    .String("object serviceProvider,")
                    .String("object targetObject,")
                    .String("global::DanielWillett.ModularRpcs.Protocol.RpcOverhead overhead,")
                    .String("global::DanielWillett.ModularRpcs.Routing.IRpcRouter router,")
                    .String("global::DanielWillett.ModularRpcs.Serialization.IRpcSerializer serializer,")
                    .String("global::System.IO.Stream stream,")
                    .String("global::System.Threading.CancellationToken token)").Out()
                .String("{").In();

            new ReceiveMethodSnippetGenerator(Context, Compilation, method)
                .GenerateMethodBodySnippet(bldr, stream: true);

            bldr.Out()
                .String("}")
                .Empty();
        }
        bldr.String("#endregion").Out();

        bldr.String("}").Out()
            .String("}")
            .String("#nullable restore");

        Context.AddSource(Class.Type.FileName, SourceText.From(bldr.ToString(), Encoding.UTF8));
    }
}