<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="InternalsNotVisibleMemberAccessException" xml:space="preserve">
    <value>The constructor you're trying to use is not accessible or overridable by the proxy class. RPC send methods must be virtual or abstract (therefore non-static). To use internal constructors or methods, it's required to add '[assembly: InternalsVisibleTo("ModularRPCs.Proxy")]' to your AssemblyInfo file.</value>
  </data>
  <data name="MethodHasNoDeclaringType" xml:space="preserve">
    <value>Method must have a declaring type.</value>
  </data>
  <data name="PrivatesNotVisibleMissingMethodException" xml:space="preserve">
    <value>The constructor you're trying to use was not found. Private constructors are not supported with RPC proxies.</value>
  </data>
  <data name="RpcFireAndForgetExceptionReturnValue" xml:space="preserve">
    <value>Fire-and-forget methods can not return a value, such is the case in {0}.</value>
  </data>
  <data name="RpcGetResultUsageException" xml:space="preserve">
    <value>GetResult can not be explicitly called by user code.</value>
  </data>
  <data name="TypeNotInheritable" xml:space="preserve">
    <value>The given type must be a non-sealed, non-abstract class to be used as an RPC proxy.</value>
  </data>
  <data name="TypeNotPublic" xml:space="preserve">
    <value>The given type and its declaring types must be public (or internal, given '[assembly: InternalsVisibleTo("ModularRPCs.Proxy")]' is in your AssemblyInfo file) to be used as an RPC proxy.</value>
  </data>
  <data name="TypeNotReferenceType" xml:space="preserve">
    <value>The given type must be a reference type (not a value type).</value>
  </data>
  <data name="ConnectionNotLoopback" xml:space="preserve">
    <value>Connection must be of type 'LoopbackRpcServerConnection'.</value>
  </data>
  <data name="RpcConnectionClosedException" xml:space="preserve">
    <value>This RPC connection is closed.</value>
  </data>
  <data name="LoopbackRemoteConnectionExpectedServersideEndpoint" xml:space="preserve">
    <value>Endpoint is not valid, expected serverside endpoint.</value>
  </data>
  <data name="LoopbackRemoteConnectionExpectedClientsideEndpoint" xml:space="preserve">
    <value>Endpoint is not valid, expected clientside endpoint.</value>
  </data>
  <data name="DidNotPassAnyDataToRpcSendDataAsync" xml:space="preserve">
    <value>Must pass either stream data or binary data to SendDataAsync.</value>
  </data>
  <data name="ContiguousBufferParseException" xml:space="preserve">
    <value>The ContiguousBuffer failed to separate out a message segment, likely due to bad data.</value>
  </data>
  <data name="RpcOverheadParseException" xml:space="preserve">
    <value>The RpcOverhead failed to parse a proper overhead, likely due to bad data.</value>
  </data>
  <data name="RpcOverheadParseExceptionUnknownRpcDescriptor" xml:space="preserve">
    <value>The RpcOverhead failed to parse a proper overhead, unknown RpcDescriptor: {0}.</value>
  </data>
  <data name="RpcEndpointNotFoundException" xml:space="preserve">
    <value>The endpoint data from a message could not be linked to an invocation point.</value>
  </data>
  <data name="RpcOverheadParseExceptionStreamRunOut" xml:space="preserve">
    <value>The RpcOverhead failed to parse a proper overhead because the stream ended too early.</value>
  </data>
  <data name="RpcOverheadParseExceptionBufferRunOut" xml:space="preserve">
    <value>The RpcOverhead failed to parse a proper overhead because the buffer was too short.</value>
  </data>
  <data name="InstanceWithThisIdAlreadyExists" xml:space="preserve">
    <value>An {1} of {0} and this id has already been registered.</value>
  </data>
  <data name="InstanceIdDefaultValue" xml:space="preserve">
    <value>An {1} of {0}'s identifier still had it's default value after the base constructor.</value>
  </data>
  <data name="InstanceIdNotSet" xml:space="preserve">
    <value>An {1} of {0}'s identifier was not set in the base constructor.</value>
  </data>
  <data name="RpcNotImplemented" xml:space="preserve">
    <value>This RPC caller was not inherited by a parent class. Make sure you're getting this service's object from the ProxyGenerator or that the service was registered using one of the Rpc IServiceCollection extensions.</value>
  </data>
  <data name="GetObjectByIdentifierIdentityTypeNotCorrectType" xml:space="preserve">
    <value>The given identifier type is not valid. Expected: '{0}', actual: '{1}'.</value>
  </data>
  <data name="RpcOverheadParseExceptionIdentifierDeclaringTypeNotFound" xml:space="preserve">
    <value>The RpcOverhead failed to parse a proper overhead because the declaring type was not available on the receving end.</value>
  </data>
  <data name="RpcOverheadParseExceptionIdentifierNotExists" xml:space="preserve">
    <value>The RpcOverhead failed to parse a proper overhead because the identifier '{0}' has not been created locally.</value>
  </data>
  <data name="ObjectNotIdentifyableType" xml:space="preserve">
    <value>The given type is not able to have an identifier.</value>
  </data>
  <data name="RpcOverheadParseExceptionStringLengthOverflow" xml:space="preserve">
    <value>The RpcOverhead failed to parse a proper overhead because the string identifier had a length well over the max, likely due to corrupted data.</value>
  </data>
  <data name="RpcOverheadParseExceptionInvalidTypeCode" xml:space="preserve">
    <value>The RpcOverhead failed to parse a proper overhead because the type code '{0}' is not a known type code.</value>
  </data>
  <data name="RpcOverheadParseExceptionUnknownIdentifierType" xml:space="preserve">
    <value>The RpcOverhead failed to parse a proper overhead because the identifier type '{0}' couldn't be found.</value>
  </data>
  <data name="RpcOverflowException" xml:space="preserve">
    <value>The buffer overflowed while writing an RPC's arguments.</value>
  </data>
  <data name="RpcOverflowExceptionIBinaryTypeParser" xml:space="preserve">
    <value>The buffer overflowed while writing from the binary type parser: '{0}'.</value>
  </data>
  <data name="RpcParseExceptionBufferRunOutIBinaryTypeParser" xml:space="preserve">
    <value>The RpcOverhead failed to parse a message because the buffer was too short while reading from the binary type parser: '{0}'.</value>
  </data>
  <data name="RpcParseExceptionStreamRunOutIBinaryTypeParser" xml:space="preserve">
    <value>The RpcOverhead failed to parse a message because the stream ended too early while reading from the binary type parser: '{0}'.</value>
  </data>
  <data name="BinaryTypeParserNotVariableSizeGetSizeNotImplemented" xml:space="preserve">
    <value>This BinaryTypeParser has IsVariableSize set to true but didn't override GetSize.</value>
  </data>
  <data name="RpcInvalidParameterException" xml:space="preserve">
    <value>A parameter in an RPC is not serializable.</value>
  </data>
  <data name="RpcInvalidParameterExceptionInfo" xml:space="preserve">
    <value>Parameter #{0}, {1} in {2} is not serializable. {3}.</value>
  </data>
  <data name="RpcInvalidParameterExceptionOutMessage" xml:space="preserve">
    <value>Out parameters are not supported</value>
  </data>
  <data name="RpcInvalidParameterExceptionInfoNoParamInfo" xml:space="preserve">
    <value>Parameter of type {0} is not serializable. {1}.</value>
  </data>
  <data name="RpcInvalidParameterExceptionNoParserFound" xml:space="preserve">
    <value>Unable to find an IBinaryTypeParser for the type</value>
  </data>
  <data name="RpcParseExceptionBufferRunOutNativeIntOverflow" xml:space="preserve">
    <value>The RpcOverhead failed to parse a message because the native int value was too long for this system while reading from the binary type parser: '{0}'.</value>
  </data>
  <data name="RpcInjectionException" xml:space="preserve">
    <value>An injected parameter in an RPC receive method is not able to be injected.</value>
  </data>
  <data name="RpcInjectionExceptionInfo" xml:space="preserve">
    <value>Injected parameter '{0}' of type {1} in method {2} is not able to be injected.</value>
  </data>
  <data name="RpcInjectionExceptionInstanceNull" xml:space="preserve">
    <value>Unable to find an available instance of {0} to invoke {1} with.</value>
  </data>
  <data name="RpcEndpointNotFoundExceptionMismatchHash" xml:space="preserve">
    <value>The endpoint data from a message could not be linked to an invocation point. The signature hash was a mis-match, likely caused by a version mismatch between server and client.</value>
  </data>
  <data name="RpcParseException" xml:space="preserve">
    <value>The RpcOverhead failed to read a message, likely due to bad data.</value>
  </data>
  <data name="RpcParseExceptionBufferRunOut" xml:space="preserve">
    <value>The RpcOverhead failed to parse a message because the buffer was too short.</value>
  </data>
  <data name="RpcParseExceptionStreamRunOut" xml:space="preserve">
    <value>The RpcOverhead failed to parse a message because the stream ended too early.</value>
  </data>
  <data name="RpcInvalidParameterExceptionGenericMethod" xml:space="preserve">
    <value>Generic methods are not supported, as is the case with {0}.</value>
  </data>
  <data name="RpcInvalidParameterExceptionReturnType" xml:space="preserve">
    <value>The return type of method '{0}' is not supported. It must be void, RpcTask, or RpcTask&lt;T&gt;.</value>
  </data>
  <data name="MethodNotCallMethod" xml:space="preserve">
    <value>The given method '{0}' was not a call/invoke method. It must be decorated with the RpcSendAttribute.</value>
  </data>
</root>